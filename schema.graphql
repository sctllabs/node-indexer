# noinspection GraphQLUnresolvedReference,GraphQLDuplicateDirective,GraphQLMissingType
type Account @entity {
    "Account address"
    id: ID!
    memberOfCouncil: [CouncilAccount!] @derivedFrom(field: "account")
    memberOfTechnicalCommittee: [TechnicalCommitteeAccount] @derivedFrom(field: "account")
}

type CouncilAccount @entity {
    id: ID!
    account: Account!
    dao: Dao!
}

type TechnicalCommitteeAccount @entity {
    id: ID!
    account: Account!
    dao: Dao!
}

type Dao @entity {
    id: ID!
    account: Account!
    founder: Account!
    council: [CouncilAccount!] @derivedFrom(field: "dao")
    technicalCommittee: [TechnicalCommitteeAccount!] @derivedFrom(field: "dao")
    name: String!
    purpose: String!
    metadata: String!
    fungibleToken: FungibleToken
    ethTokenAddress: String
    policy: Policy!
    proposals: [Proposal] @derivedFrom(field: "dao")
}

enum ApproveOriginType {
    AtLeast
    MoreThan
}

enum GovernanceKind {
    GovernanceV1
    OwnershipWeightedVoting
}

type GovernanceV1 {
    kind: GovernanceKind!
    enactmentPeriod: BigInt!
    launchPeriod: BigInt!
    votingPeriod: BigInt!
    voteLockingPeriod: BigInt!
    fastTrackVotingPeriod: BigInt!
    cooloffPeriod: BigInt!
    minimumDeposit: BigInt!
    externalOrigin: ApproveOriginType!
    externalMajorityOrigin: ApproveOriginType!
    externalDefaultOrigin: ApproveOriginType!
    fastTrackOrigin: ApproveOriginType!
    instantOrigin: ApproveOriginType!
    instantAllowed: Boolean!
    cancellationOrigin: ApproveOriginType!
    blacklistOrigin: ApproveOriginType!
    cancelProposalOrigin: ApproveOriginType!
}

type OwnershipWeightedVoting {
    kind: GovernanceKind!
}

union Governance = GovernanceV1 | OwnershipWeightedVoting

type Policy @entity {
    id: ID!
    proposalPeriod: Int!
    approveOriginType: ApproveOriginType!
    approveOriginProportion: [Int!]!
    governance: Governance
}

type FungibleToken @entity {
    id: ID!
    name: String!
    symbol: String!
    decimals: Int
    isFrozen: Boolean!
}

# TODO @asansyzb investigate difference between Yes/No voting and count based voting

type AddMember {
    who: Account!
}

type RemoveMember {
    who: Account!
}

type Spend {
    amount: BigInt!
    beneficiary: Account!
}

union ProposalKind = AddMember | RemoveMember | Spend

type Proposal @entity {
    id: ID!
    index: String!
    hash: String!
    account: Account!
    dao: Dao!
    voteThreshold: Int!
    kind: ProposalKind!
    meta: String
}

type VoteHistory @entity {
    id: ID!
    proposalHash: Proposal
    approvedVote: Boolean!
    councillor: Account
    votedYes: Int
    votedNo: Int
    block: BigInt!
}