# noinspection GraphQLUnresolvedReference,GraphQLDuplicateDirective,GraphQLMissingType

# start Account
type Account @entity {
  "Account address"
  id: ID!
}
# end Account

# start Dao
type Dao @entity {
  id: ID!
  account: Account!
  founder: Account!
  council: [String!]!
  technicalCommittee: [String!]!
  name: String!
  purpose: String!
  metadata: String!
  fungibleToken: FungibleToken
  ethTokenAddress: String
  policy: Policy!
  proposals: [CouncilProposal]! @derivedFrom(field: "dao")
  createdAt: DateTime!
  blockHash: String!
  blockNum: Int!
}

enum ApproveOriginType {
  AtLeast
  MoreThan
}

enum GovernanceKind {
  GovernanceV1
  OwnershipWeightedVoting
}

type GovernanceV1 {
  kind: GovernanceKind!
  enactmentPeriod: Int!
  launchPeriod: Int!
  votingPeriod: Int!
  voteLockingPeriod: Int!
  fastTrackVotingPeriod: Int!
  cooloffPeriod: Int!
  minimumDeposit: BigInt!
  externalOrigin: ApproveOriginType!
  externalMajorityOrigin: ApproveOriginType!
  externalDefaultOrigin: ApproveOriginType!
  fastTrackOrigin: ApproveOriginType!
  instantOrigin: ApproveOriginType!
  instantAllowed: Boolean!
  cancellationOrigin: ApproveOriginType!
  blacklistOrigin: ApproveOriginType!
  cancelProposalOrigin: ApproveOriginType!
}

type OwnershipWeightedVoting {
  kind: GovernanceKind!
}

union Governance = GovernanceV1 | OwnershipWeightedVoting

type Policy @entity {
  id: ID!
  proposalPeriod: Int!
  bountyPayoutDelay: Int!
  bountyUpdatePeriod: Int!
  approveOriginType: ApproveOriginType!
  approveOriginProportion: [Int!]!
  governance: Governance
}
# end Dao

# start Token
type FungibleToken @entity {
  id: ID!
  name: String!
  symbol: String!
  decimals: Int
  isFrozen: Boolean!
  createdAt: DateTime!
  blockHash: String!
  blockNum: Int!
}
# end Token

# start Proposal types
type AddMember {
  who: String!
}

type RemoveMember {
  who: String!
}

type Spend {
  amount: BigInt!
  beneficiary: String!
}

type TransferToken {
  amount: BigInt!
  beneficiary: String!
}

type CreateBounty {
  daoId: Int!
  value: BigInt!
  description: String!
}

type CreateTokenBounty {
  daoId: Int!
  tokenId: BigInt
  value: BigInt!
  description: String!
}

type ProposeCurator {
  bountyId: Int!
  curator: String!
  fee: BigInt
}

type UnassignCurator {
  daoId: Int!
  bountyId: Int!
}
# end Proposal types

# start CouncilProposal
union CouncilProposalKind =
    AddMember
  | RemoveMember
  | Spend
  | TransferToken
  | CreateBounty
  | CreateTokenBounty
  | ProposeCurator
  | UnassignCurator

enum CouncilProposalStatus {
  Open
  Approved
  Disapproved
  Executed
  Closed
}

type CouncilProposal @entity {
  id: ID!
  index: Int!
  hash: String!
  account: Account!
  dao: Dao!
  voteThreshold: Int!
  kind: CouncilProposalKind!
  meta: String
  createdAt: DateTime!
  updatedAt: DateTime!
  blockHash: String!
  blockNum: Int!
  status: CouncilProposalStatus!
}

type CouncilVoteHistory @entity {
  id: ID!
  proposal: CouncilProposal
  approvedVote: Boolean!
  councillor: Account
  votedYes: Int
  votedNo: Int
  createdAt: DateTime!
  updatedAt: DateTime!
  blockHash: String!
  blockNum: Int!
}
# end CouncilProposal

# start DemocracyProposal
union DemocracyProposalKind =
    AddMember
  | RemoveMember
  | Spend
  | TransferToken
  | CreateBounty
  | CreateTokenBounty
  | ProposeCurator
  | UnassignCurator

enum DemocracyProposalStatus {
  Open
  Referendum
}

type DemocracyProposal @entity {
  id: ID!
  index: Int!
  account: Account!
  dao: Dao!
  deposit: BigInt!
  kind: DemocracyProposalKind!
  meta: String
  createdAt: DateTime!
  updatedAt: DateTime!
  blockHash: String!
  blockNum: Int!
  status: DemocracyProposalStatus!
}

type DemocracySecond @entity {
  id: ID!
  seconder: Account!
  count: Int!
  proposal: DemocracyProposal!
  createdAt: DateTime!
  updatedAt: DateTime!
  blockHash: String!
  blockNum: Int!
}
# end DemocracyProposal

# start DemocracyReferendum
enum DemocracyReferendumStatus {
  Started
  Passed
  NotPassed
  Cancelled
}

enum DemocracyReferendumVoteThreshold {
  SuperMajorityApprove
  SuperMajorityAgainst
  SimpleMajority
}

type DemocracyReferendum @entity {
  id: ID!
  voteThreshold: DemocracyReferendumVoteThreshold!
  democracyProposal: DemocracyProposal!
  status: DemocracyReferendumStatus!
  index: Int!
  blockHash: String!
  blockNum: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}
# end DemocracyReferendum

# start DemocracyDelegation
enum Conviction {
  None
  Locked1x
  Locked2x
  Locked3x
  Locked4x
  Locked5x
  Locked6x
}

type DemocracyDelegation @entity {
  id: ID!
  account: Account!
  target: Account!
}
# end DemocracyDelegation

# start Bounty

enum BountyStatus {
  Created
  BecameActive
  CuratorProposed
  CuratorUnassigned
  CuratorAccepted
  Awarded
  Claimed
  Cancelled
  Extended
}

type Bounty @entity {
  id: ID!
  dao: Dao!
  index: Int!
  status: BountyStatus!
  nativeToken: Boolean!
  description: String!
  value: BigInt!
  curator: Account
  beneficiary: Account
  updateDue: Int
  unlockAt: Int
  fee: BigInt
  payout: BigInt
  blockHash: String!
  blockNum: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

# end Bounty

# start EthGovernanceProposal
union EthGovernanceProposalKind =
    AddMember
  | RemoveMember
  | Spend
  | TransferToken
  | CreateBounty
  | CreateTokenBounty
  | ProposeCurator
  | UnassignCurator

enum EthGovernanceProposalStatus {
  Open
  Approved
  Disapproved
  Executed
  Closed
}

type EthGovernanceProposal @entity {
  id: ID!
  index: Int!
  hash: String!
  account: Account!
  dao: Dao!
  voteThreshold: BigInt!
  kind: EthGovernanceProposalKind!
  meta: String
  createdAt: DateTime!
  updatedAt: DateTime!
  blockHash: String!
  blockNum: Int!
  status: EthGovernanceProposalStatus!
}

type EthGovernanceVoteHistory @entity {
  id: ID!
  proposal: EthGovernanceProposal
  approvedVote: Boolean!
  account: Account
  aye: Boolean
  balance: BigInt
  createdAt: DateTime!
  updatedAt: DateTime!
  blockHash: String!
  blockNum: Int!
}
# end EthGovernanceProposal
